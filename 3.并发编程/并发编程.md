## 线程共享与写作

参考文章[https://www.jianshu.com/p/594ed18205dc]
百度百科[https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6/3059054]
可见性、原子性和有序性问题：并发编程Bug的源头
[https://time.geekbang.org/column/article/83682]

关键字 互斥、同步

### CPU核心数、线程数

两者的关系:cpu的核心数和线程数一般是1:1的关系，即8核的cpu，同时支持8个线程同时运行。但在intel引入超线程技术后，cpu与线程数的关系变成了1:2。
开发过程中无法感知到线程的限制，由于cpu时间轮转机制[RR调度]的算法作用。


### CPU时间片轮转机制(Round-Robin)

系统把所有就绪的进程排成队里,按照先入先出的原则执行进程。cpu给每个进程分配了一个时间片(时间片是一个小的时间单位,通常为10~100ms数量级)。当进程用完分给它的时间片后，系统将会停止该进程的运行，把它放到就绪队列的末尾，从而继续从队列中取出第一个进行分配时间片。cpu在进程之间的切换称为"上下文切换"。


### 管程

指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。Java中为:管理类的成员变量和成员方法，让这个类是线程安全的。



### 并发编程-可见性

一个线程对共享变量的修改,另一个线程能立即看到。

### 并发编程-原子性

一个或多个操作在cpu执行的过程中不被中断的特性叫原子性。

### 并发编程-有序性

有序性指的是程序按照代码的先后顺序执行。

### Happens-Before 规则【Happens-Before的意思是前面一个操作的结果对后续操作是可见的】

-顺序性：一个线程中的每个操作，happens-before于该线程中的任意后续操作。

-传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。

-监视器锁规则：线程A执行完代码块后（执行完自动释放锁），线程B进入代码块时，能够看到线程A对变量的写操作。

-start()规则：它是指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。

-join()规则：它是指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。

-程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。

-对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。

### synchronized

synchronized是Java里对管程的实现。synchronized修饰的代码块/方法 会自动加锁和释放锁

### volatile

volatile最适用的场景：一个线程写，多个线程读。

### wait()、notify()、notifyAll()

wait()方法会让当前线程阻塞

notify()会随机地通知等待队列中的一个线程。

notifyAll()会通知等待队列中的所有线程。







