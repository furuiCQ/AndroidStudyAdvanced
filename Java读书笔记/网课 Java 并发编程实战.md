网课 Java 并发编程实战.md

# 可见性、原子性、有序性

一个线程对共享变量的修改，另一个线程能够立刻看到，我们称为可见性。

我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性。

有序性指的是程序按照代码的先后顺序执行。

## Java内存模型: 看Java如何解决可见性和有序性问题

### volatile

原始意义是禁用CPU缓存。

### Happens-Before 规则

前面一个操作的结果对后续操作是可见的。

1.程序的顺序性规则。

在一个线程中，按照程序顺序，前面的操作Happens-before与后续的任意操作。

2.volatile变量规则

这条规则是指对一个volatile变量的写操作，Happens-Before于后续对这个volatile变量的读操作。

3.传递性。

这条规则是指如果A Happens-Before B，且B Happens-Before C，那么A Happens-Before C。


4.管程中锁的规则

这条规则是指对一个锁的解锁Happens-Before于后续对这个所得枷锁。

管程是一种通用的同步原语，在Java中指的就是synchronized,synchronized是Java里对管程的实现。



5.线程start()规则

这条是关于线程启动的。它是指主线程A启动子线程B后，子线程B能够看到主线程在启动子线程B前的操作。

换句话说就是，如果线程A调用线程B的 start() 方法（即在线程A中启动线程B），那么该start()操作 Happens-Before 于线程B中的任意操作。



6. 线程join()规则

这条是关于线程等待的。它是指主线程A等待子线程B完成（主线程A通过调用子线程B的join()方法实现），当子线程B完成后（主线程A中join()方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作。

换句话说就是，如果在线程A中，调用线程B的 join() 并成功返回，那么线程B中的任意操作Happens-Before 于该 join() 操作的返回。

## 被我们忽略的final

final修饰变量时，初衷是告诉编译器：这个变量生而不变，可以可劲儿优化。

发布一个对象的意思是使它能够被当前范围之外的代码所使用。
逸出是指一个对象在尚未准备好时就将它发布。


# 解决原子性问题

原子性问题的源头是线程切换。

”同一时刻只有一个线程执行“,我们称之为互斥。

我们把一段需要互斥执行的代码称为临界区。

## synchronized

```java

class X{
	//修饰非静态方法 锁的是this
	synchronized void foo(){
	//临界区
	}
	//修饰静态方法 锁的是X.class
	synchronized static void bar(){
		//临界区
	}
	//修饰代码块 锁的是指定对象obj
	Object obj=new Object();
	void baz(){
		synchronized(obj){
			//临界区
		}
	}
}

```

当修饰静态方法的时候，锁定的是当前类的Class对象，在上面的例子中就是ClassX.
当修饰费静态方法的时候，锁定的是当前实例对象this。

## 锁和受保护资源的关系

一个合理的关系是:受保护资源和锁质检的关系是N:1的关系。

总结:

对于并发问题,深入分析锁定的对象和受保护资源的关系，综合考虑受保护资源的访问路径，多方面考量才能用好互斥锁.

synchronized是Java在语言层面提供的互斥原语，其实Java里面还有很多其他类型的锁，但作为互斥锁，原理都是相通的：锁，一定有一个要锁定的对象，至于这个锁定的对象要保护的资源以及在哪里加锁/解锁，就属于设计层面的事情了.

## 保护没有关联关系的多个资源

用不同的锁对受保护资源进行精细化管理，能够提升性能，叫细粒度锁。

## 保护有关联关系的多个资源

锁能覆盖所有受保护的资源。例如xxx.class作为锁的对象

总结:

对如何保护多个资源已经很有心得了，关键是要分析多个资源之间的关系。如果资源之间没有关系，很好处理，每个资源一把锁就可以了。如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。除此之外，还要梳理出有哪些访问路径，所有的访问路径都要设置合适的锁来保护。

“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。例如，在32位的机器上写long型变量有中间状态（只写了64位中的32位），在银行转账的操作中也有中间状态（账户A减少了100，账户B还没来得及发生变化）。所以解决原子性问题，是要保证中间状态对外不可见。


## 一不小心死锁了，怎么办？

使用细粒度锁可以提高并发度，是性能优化的一个重要手段。

细粒度锁有可能导致死锁。

死锁的定义是:一组互相竞争资源的线程因互相等待，导致"永久"阻塞的现象。

只有以下这四个条件都发生时才会出现死锁:

1. 互斥,共享资源X和Y只能被一个线程占用;
2. 占有且等待，线程T1已经取得共享资源X,在等待共享资源Y的时候，不释放共享资源X;
3. 不可抢占,其他线程不能强行抢占线程T1占有的资源;
4. 循环等待，线程T1等待线程T2 占有的资源，线程T2等待线程T1占有的资源，就是循环等待。


预防死锁

1. 破坏占用且等待条件【保证”一次性申请所有资源“】

2. 破坏不可抢占条件 

3. 破坏循环等待条件 


## 用"等待-通知" 机制优化循环等待

一个完整的等待-通知机制:线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态;当要求的条件满足时，通知等待的线程，重新获取互斥锁。


### 尽量使用notifyAll()

notify()是会随机地通知等待队列中的一个线程,而notfiyAll()会通知等待队列中的所有线程。


## wait()方法与sleep()方法的不同之处在于:

1. wait会释放所有锁而sleep不会释放锁资源.
2. wait只能在同步方法和同步块中使用，而sleep任何地方都可以.
3. wait无需捕捉异常，而sleep需要.（都抛出InterruptedException ，wait也需要捕获异常）
4. wait()无参数需要唤醒，线程状态WAITING；wait(1000L);到时间自己醒过来或者到时间之前被其他线程唤醒，状态和sleep都是TIME_WAITING
两者相同点：都会让渡CPU执行时间，等待再次调度！


# 安全性、活跃性、性能问题

## 安全性问题

程序按照我们期望的执行。

当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候。叫做数据竞争（Data Race）。

竞态条件，指的是程序的执行结果依赖线程执行的顺序。

## 活跃性问题

所谓活跃性问题，指的是某个操作无法执行下去。我们常见的“死锁”就是一种典型的活跃性问题，当然除了死锁外，还有两种情况，分别是“活锁”和“饥饿”。

但有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”。

解决“活锁”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。

所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况。

解决“饥饿”问题的方案很简单，有三种方案：一是保证资源充足，二是公平地分配资源，三就是避免持有锁的线程长时间执行。这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。

那如何公平地分配资源呢？在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。

## 性能问题

第一，既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构了。在这方面有很多相关的技术，例如线程本地存储(Thread Local Storage, TLS)、写入时复制(Copy-on-write)、乐观锁等；Java并发包里面的原子类也是一种无锁的数据结构；Disruptor则是一个无锁的内存队列，性能都非常好……

第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是Java并发包里的ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。

性能方面的度量指标有很多，有三个指标非常重要，就是：吞吐量、延迟和并发量。

吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。
并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是1000的时候，延迟是50毫秒。 

总结:

并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。

我们在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。安全性方面要注意数据竞争和竞态条件，活跃性方面需要注意死锁、活锁、饥饿等问题，性能方面我们虽然介绍了两个方案，但是遇到具体问题，你还是要具体分析，根据特定的场景选择合适的数据结构和算法。



