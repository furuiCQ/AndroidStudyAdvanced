网课 数据结构与算法之美.md

大O 时间复杂度表示法。大O时间复杂度实际上并不具体标识代码真正的执行时间，而是标识代码执行时间随数据规模增长的变化局势，也叫做渐进时间复杂度，简称时间复杂度。

## 时间复杂度分析

1. 只关注循环执行次数最多的一段代码

我们在分析一个算法、一段代码的时间复杂度的时候,也只关注循环执行次数最多的那一段代码就可以了。

2. 加法法则:总复杂度等于量级最大的那段代码的复杂度

3. 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

## 复杂度量级

* 常量阶 O(1)
* 对数阶 O(logn)
* 线性阶 O(n)
* 线性对数阶 O(nlogn)
* 平方阶 O(n²)、立方阶(n³).....k次方阶O(n^k)
* 指数阶 O(2^n) //多项式量级
* 阶乘阶 O(n!)  //非多项式量级


 ### O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，时间复杂度也是O(1).


### O(logn)、O(nlogn)

在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。

如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了。 O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)。

### O(m+n)、O(m×n)

从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，代码的时间复杂度就是O(m+n)。

## 空间复杂度分析

空间复杂度全称就是渐进空间复杂度,表示算法的存储空间与数据规模之间的增长关系。

我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。


## 最好、最坏情况时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

## 平均情况时间复杂度

平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

## 均摊时间复杂度

应用场景:对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


## 数组

数组(Array)是一种线性表数据结构。它用一组连续的内存空间,来存储一组具有相同类型数据。

### 线性表

线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前后两个方向。其实除了数组、链表、队列、栈等也是线性表结构。

非线性表 比如:二叉树、堆、图

数组支持随机访问,根据下标随机访问的时间复杂度为O(1)

ArrayList最大的优势就是可以将很多数组的操作的细节封装起来。支持动态库容。最好在创建ArrayList的时候事先指定数据大小。

1. Java ArrayList 无法存储基本类型，如果int、long,需要封装为Integer、Long类，而Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。  

2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。 

3. 表示多维数组时，用数组往往会更加直观。 

对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。


## 链表

缓存的常见淘汰策略。先进先出策略FIFO(First In,First Out)、最少使用策略LFU(Least Frequently Used),最近最少使用策略LRU(Least Recently Used)。

链表，通过"指针"将一组零散的内存块串联起来使用。


### 单链表 

```java
-->[data,next]-->[data,next]--...->NULL
```

包含内存块【结点】和后继指针。第一个结点叫做头结点，最后一个结点叫做尾结点。尾结点的后继指针指向的是一个空地址NULL,表示这是链表上最后一个结点。

链表插入删除操作的时间复杂度是O(1),
随机访问的时间复杂度是O(n)。

### 循环链表

循环链表是一种特殊的单链表。循环链表的尾结点指向的是链表的头结点。

### 双向链表 

```java
-->[prev,data,next]--><--[pre,data,next]--><--[prev,data,next]

```

单链表删除操作需要O(n)的时间复杂度。
而双向链表只需要O(1)的时间复杂度

用空间换时间的设计思想。


### 双向循环链表 

头尾相连的双向链表



### 链表 VS 数组性能大比拼

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足。如果声明的数组过小，则可能出现不够用的情况。这时只能在申请一个更大的内存空间，把原数组拷贝进去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容，这时它与数组最大的区别。

### 如何基于链接实现LRU缓存淘汰算法

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。


### 写链表代码技巧

1. 理解指针或引用的含义:将某个变量赋值给指针，实际就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

2. 警惕指针丢失和内存泄漏:插入结点时，一定要注意操作的顺序，要先将结点x的next指针指向结点b,再把结点a的next指针执行结点x，这样才不会丢失指针，导致内存泄漏。

删除链表结点时，也一定要记得手动释放内存空间。

3. 利用哨兵简化实现难度

针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。

有哨兵结点的链表叫带头链表，没有哨兵结点的链表叫作不带头链表。

4. 重点留意边界条件处理

欧诺个来检查链表代码是否正确的边界条件

* 如果链表为空时，代码是否能正常工作？
* 如果链表只包含一个结点时，代码是否能正常工作？
* 如果链表只包含两个结点时，代码是否能正常工作？
* 代码逻辑在处理头结点和尾结点的时候，是否能正常工作?

5. 举例画图,辅助思考

6. 多写多练，没有捷径

## 栈:如何实现浏览器的前进和后退功能？

后进者先出，先进者后出，这就是典型的“栈”结构。

当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选"栈"这种数据结构。

用数组实现的栈叫做顺序栈，

用链表实现的栈，我们叫做链式栈。

## 队列: 队列在线程池等有限资源池中的应用

先进者先出，这就是典型的“队列”。

队列跟栈一样，也是一种操作受限的线性表数据结构。

用数组实现的队列叫顺序队列，用链表实现的队列叫做链式队列。

循环队列要做好队空和队满的判断条件
head头指针，tail为指针，n为队列长度。
1.对空判断条件为head==tail
2.队满时为(tail+1)%n=head。


## 递归:如何用三行代码找到“最终推荐人”

递归需要满足三个条件

1. 一个问题的解可以分解为几个子问题的解

2. 这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样。

3. 存在递归终止条件



写递归代码的关键就是如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公司和终止条件翻译成代码。

编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公司，不用想一层层的调用关系，不要试图用人脑去分解递归的步骤。

### 递归代码要警惕堆栈溢出

### 避免重复计算

为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。

```java

public int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  
  // hasSolvedList可以理解成一个Map，key是n，value是f(n)
  if (hasSolvedList.containsKey(n)) {
    return hasSolvedList.get(n);
  }
  
  int ret = f(n-1) + f(n-2);
  hasSolvedList.put(n, ret);
  return ret;
}

```

递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。

## 排序(上): 为什么插入排序比冒泡排序更受欢迎?

### 排序算法的执行效率

1. 最好情况、最坏情况、平均情况时间复杂度

2. 时间复杂度的系数、常数、低阶

3. 比较次数和交换(或移动)次数


### 原地排序

原地排序算法，就是特指空间复杂度是O(1)的排序算法。

排序算法的稳定性是指:如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

### 冒泡排序

冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1),是一个原地排序算法。

在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

最好情况复杂度是O(n),最坏情况时间复杂度是O(n^2)。平均情况下的时间复杂度O(n^2).


### 插入排序

插入排序是一个原地排序算法

插入排序是稳定的排序算法

插入排序最好时间复杂度是O(n),最坏情况时间复杂度是O(n^2)。平均情况下的时间复杂度O(n^2).


### 选择排序

选择排序是一个原地排序算法

选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。

选择排序不是一个稳定的排序算法。会破坏相同元素的顺序。



## 排序(下): 如何使用快排思想在O(n)内查找第K大元素。

### 归并排序的原理

归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，在讲排好序的两部分合并在一起，这样整改数组就都有序了。

归并排序是一个稳定的排序算法。

归并排序的时间复杂度是O(nlogn)

归并排序的空间复杂度是O(n)

### 快速排序的原理

如果要排序数组中下标从p到r之间的一组数据，我们选择p到r中间的任意一个数据作为pivot(分区点).

我们遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot的放到右边，将pivot放到中间。经过这一步骤之后，数组p到r之间的数据就被分成了三部分,签名p到q-1之间都是小于pivot的，中间是pivot，后面的q+1到r之间是大于pivot的。

快排的时间复杂度也是O(nlogn)。T(n)在大部分情况下的时间复杂度都可以做到O(nlogn),只有在极端情况下，才会退化到O(n^2)。

## 线性排序:如何根据年龄给100万用户数据排序


### 桶排序

核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据在单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次去除，组成的序列就是有序的了。


### 计数排序

计数排序其实是桶排序的特殊情况。

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。

```java
//a[] [2，5，3，0，2，3，0，3]
// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。
public void countingSort(int[] a, int n) {
  if (n <= 1) return;

  // 查找数组中数据的范围
  int max = a[0]; //max=2
  for (int i = 1; i < n; ++i) {
    if (max < a[i]) {
      max = a[i];
    }
  }
//max=5
  int[] c = new int[max + 1]; // 申请一个计数数组c，下标大小[0,max] c[6]
  for (int i = 0; i <= max; ++i) {
    c[i] = 0; //c每个元素置为0
  }

  // 计算每个元素的个数，放入c中
  for (int i = 0; i < n; ++i) {
    c[a[i]]++;
  }
//c[6] [2,0,2,3,0,1]
  // 依次累加 数组顺序求和 
  for (int i = 1; i <= max; ++i) {
    c[i] = c[i-1] + c[i];
  }
  //c[6] [2,2,4,7,7,8]

  // 临时数组r，存储排序之后的结果
  int[] r = new int[n];
  // 计算排序的关键步骤，有点难理解
  for (int i = n - 1; i >= 0; --i) { //i=7;i>=0; --i
    int index = c[a[i]]-1; 
    r[index] = a[i];  //把a数组中的元素拷贝到r数组第index位置。
    c[a[i]]--; //c数组代表元素求和位置的数字-1.
  }

  // 将结果拷贝给a数组
  for (int i = 0; i < n; ++i) {
    a[i] = r[i];
  }
}

```

### 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的”位“来比较，而且位之间有递进关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。




## 排序优化:如何实现一个通用的、高性能的排序函数

如果对小规模数据进行排序，可以选择时间复杂度是O(n^2)的算法;如果对大规模数据进行排序，时间复杂度是O(nlogn)的算法更加高效。所以，为了兼顾任意规模数据的排序，一般会首选时间复杂度是O(nlogn)的排序算法来实现排序函数。


### 分区算法

1. 三数取中法
我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。


2. 随机法


对于小规模数据的排序，O(n^2)的排序算法并不一定比O(nlogn)排序算法执行的时间长。对于小数据量的排序，我们选择比较简单、不需要递归的插入排序算法。



## 二分查找(上): 如何用最省内存的方式实现快速查找功能？

### 二分查找法

时间复杂度是O(logn)

使用场景:底层必须依赖数组，并且还要求数据是有序的。
二分查找更适合处理静态数据，也就是没有频繁的数据插入、删除操作。



### 二分查找的递归与非递归实现

```java


public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {//*
    //mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。
    int mid = (low + high) / 2;

    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      low = mid + 1;
      //注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。
    } else {
      high = mid - 1;
      //注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。
    }
  }

  return -1;
}

```

```java


// 二分查找的递归实现
public int bsearch(int[] a, int n, int val) {
  return bsearchInternally(a, 0, n - 1, val);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
  if (low > high) return -1;

  int mid =  low + ((high - low) >> 1);
  if (a[mid] == value) {
    return mid;
  } else if (a[mid] < value) {
    return bsearchInternally(a, mid+1, high, value);
  } else {
    return bsearchInternally(a, low, mid-1, value);
  }
}

```



## 二分查找(下): 如何快速定位IP对应的省份地址？

如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。


然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。

当我们要查询某个 IP 归属地时，我们可以先通过二分查找，找到最后一个起始 IP 小于等于这个 IP 的 IP 区间，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。




















