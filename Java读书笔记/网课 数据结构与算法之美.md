网课 数据结构与算法之美.md

大O 时间复杂度表示法。大O时间复杂度实际上并不具体标识代码真正的执行时间，而是标识代码执行时间随数据规模增长的变化局势，也叫做渐进时间复杂度，简称时间复杂度。

## 时间复杂度分析

1. 只关注循环执行次数最多的一段代码

我们在分析一个算法、一段代码的时间复杂度的时候,也只关注循环执行次数最多的那一段代码就可以了。

2. 加法法则:总复杂度等于量级最大的那段代码的复杂度

3. 乘法法则:嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

## 复杂度量级

* 常量阶 O(1)
* 对数阶 O(logn)
* 线性阶 O(n)
* 线性对数阶 O(nlogn)
* 平方阶 O(n²)、立方阶(n³).....k次方阶O(n^k)
* 指数阶 O(2^n) //多项式量级
* 阶乘阶 O(n!)  //非多项式量级


 ### O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，时间复杂度也是O(1).


### O(logn)、O(nlogn)

在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为O(logn)。

如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了。 O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)。

### O(m+n)、O(m×n)

从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，代码的时间复杂度就是O(m+n)。

## 空间复杂度分析

空间复杂度全称就是渐进空间复杂度,表示算法的存储空间与数据规模之间的增长关系。

我们常见的空间复杂度就是O(1)、O(n)、O(n2 )，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。


## 最好、最坏情况时间复杂度

最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。

最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。

## 平均情况时间复杂度

平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。

## 均摊时间复杂度

应用场景:对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。


## 数组

数组(Array)是一种线性表数据结构。它用一组连续的内存空间,来存储一组具有相同类型数据。

### 线性表

线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前后两个方向。其实除了数组、链表、队列、栈等也是线性表结构。

非线性表 比如:二叉树、堆、图

数组支持随机访问,根据下标随机访问的时间复杂度为O(1)

ArrayList最大的优势就是可以将很多数组的操作的细节封装起来。支持动态库容。最好在创建ArrayList的时候事先指定数据大小。

1. Java ArrayList 无法存储基本类型，如果int、long,需要封装为Integer、Long类，而Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。  

2. 如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。 

3. 表示多维数组时，用数组往往会更加直观。 

对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。


## 链表

缓存的常见淘汰策略。先进先出策略FIFO(First In,First Out)、最少使用策略LFU(Least Frequently Used),最近最少使用策略LRU(Least Recently Used)。

链表，通过"指针"将一组零散的内存块串联起来使用。


### 单链表 

```java
-->[data,next]-->[data,next]--...->NULL
```

包含内存块【结点】和后继指针。第一个结点叫做头结点，最后一个结点叫做尾结点。尾结点的后继指针指向的是一个空地址NULL,表示这是链表上最后一个结点。

链表插入删除操作的时间复杂度是O(1),
随机访问的时间复杂度是O(n)。

### 循环链表

循环链表是一种特殊的单链表。循环链表的尾结点指向的是链表的头结点。

### 双向链表 

```java
-->[prev,data,next]--><--[pre,data,next]--><--[prev,data,next]

```

单链表删除操作需要O(n)的时间复杂度。
而双向链表只需要O(1)的时间复杂度

用空间换时间的设计思想。


### 双向循环链表 

头尾相连的双向链表



### 链表 VS 数组性能大比拼

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没法有效预读。

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致内存不足。如果声明的数组过小，则可能出现不够用的情况。这时只能在申请一个更大的内存空间，把原数组拷贝进去，非常耗时。链表本身没有大小的限制，天然地支持动态扩容，这时它与数组最大的区别。

### 如何基于链接实现LRU缓存淘汰算法

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

2. 如果此数据没有在缓存链表中，又可以分为两种情况：如果此时缓存未满，则将此结点直接插入到链表的头部；如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。



