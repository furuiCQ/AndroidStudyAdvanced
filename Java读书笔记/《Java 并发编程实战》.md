《Java 并发编程实战》.md

## 线程的优点

恰当地使用线程时，可以降低开发和维护的开销，并且能够提高复杂应用的性能。

## 线程安全

一开始就将一个类设计成线程安全的，比在后期重新修复它更容易。

一个类是线程安全的是指在被多个线程访问时，类可以持续进行正确的行为。


## 原子性

## 竞争条件

### 惰性初始化

### 复合操作

我们将"检查在运行"和读-改-写操作的全部执行过程看作是复合操作。

### 锁

为了保护状态的一致性，要在单一的原子操作中更新相关的状态变量。

### 内部锁 synchronized

### 重进入 

### 活跃度与性能

通常简单性与性能质之间是互相牵制的。实现一个同步策略时，不要过早地为了性能而牺牲简单性(这是对安全性潜在的妥协)。

有些耗时的计算或操作，比如网络或I/O,难以快速完成。执行这些操作期间不要占有锁。

## 共享对象

### 可见性

### 过期数据

### 非原子的64位操作

当一个线程在没有同步的情况下读取变量，它可能得到一个过气质。但是至少它可以看到某个线程在那里设定的一个真实数值，而不是一个凭空而来的值。这样的安全性保证被称为最低限的安全性。

### 锁和可见性

锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。

### Volatile 变量

只有当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免volatile变量。正确使用volatile变量的方式包括:用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件(比如初始化或关闭)的发生。

只有满足下条件才能使用volatile变量

* 写入变量时并不依赖变量的当前值；或者能保证只有单一的线程修改变量的值

* 变量不需要与其他的状态变量共同参与不变约束

* 访问变量时，没有其他原因需要加锁。


### 发布和逸出

发布一个对象的意思是使它能够被当前范围之外的代码所使用。
逸出是指 一个对象在尚未准备好时就将它发布。

在很多情况下，我们需要确保对象及它们的内部状态不被暴露。最常见的发布对象方式是将对象的引用存储到公共静态域中。
另一种发布对象和它的内部状态的机制是发布一个内部类实例。


### 安全构件的实践

### 线程封闭

线程限制是你在程序设计中需要考虑的一个元素，它是在程序的实现中完成的。

### Ad-hoc 线程限制

维护线程限制性的任务全部落在实现上的这种情况交Ad-hoc线程限制。

### 栈限制

栈限制是线程限制的一种特列。在栈限制中，只能通过本地变量才可以触及对象。

### ThreadLocal

一种维护线程限制的更加规范的方式是使用TreadLocal,它允许你将每个线程与持有数据的对象关联在一起。


### 不可变性

不可变对象永远是线程安全的。

不可变性并不简单第等于将对象中的所有域声明为fianl类型。因为final域可以获得一个岛可变对象的引用。

只有满足如下状态，一个对象才是不可变的。

* 它的状态不能在创建后再被修改

* 所有域都是final类型

* 并且它被正确创建(创建期间没有发生this引用的逸出)

### Final域

final关键字源于C++的const机制，不过受到了更多的限制。它对不可变性对象的创建提供了支持。fianl域是不能修改的(尽管如果final域指向的对象是可变的，这个对象仍然可被修改)，然而它在Java存储模型中还有着特殊的语义。final域使得确保初始化安全性成为可能，初始化安全性让不可变性对象不需要同步就能自由地访问和共享。

即使对象是可变的，将一些域声明为fianl类型仍然有助于简化对其状态的判断。因为限制了对象的可见性，也就约束了其可能的状态集，即使有一两个可变的状态变量，这样一个"几乎不可变"的对象仍然比有很多的可变变量的对象要简单。将域声明为fianl类型，还向维护人员明确指出这些域是不能变的。

### 不可变对象与初始化安全性

处于不可变对象的重要性，Java存储模型为共享不可变对象提供了特殊的初始化安全性的保证。正如我们所见的，对象的引用对其他线程可见，并不意味对象的状态一定对消费线程可见。为了保证对象状态有一个一致性视图，我们需要同步。

另一方面，即使发布对象引用时没有使用同步，不可变对象仍然可以被安全地方问。为了获得这种初始化安全性的保证，应该满足所有不可变性的条件:不可修改的状态，所有域都是fianl类型的，以及正确的构造。


### 安全发布的模式

如果一个对象不是不可变的，它就必须被安全地发布，通常发布线程与消费线程必须同步化。

为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布:
* 通过静态初始化器初始化对象的引用;
* 将它的引用存储到volatile域或者AtomicRefrence;
* 将它的引用存储到正确创建的对象的fianl域中;
* 或者将它的引用存储到由锁正确保护的域中。


线程安全库中的容器提供了如下的线程安全保证:

* 置于Hashtable，synchronizedMap、ConcureentMap中的主键以及键值，会安全地发布到可以从Map获得它们的任意线程中，无论是直接获得还是通过迭代器（interator）获得

* 置于Vecotr、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或者synchedSet中的元素，会安全地发布到可以从容器中获得它的任意线程中；

* 置于BlockingQueue或者ConcurrentLinkedQueue的元素，会安全地发布到可以从队列中获得它的任意线程中。


通常,以最简单和最安全的方式发布一个被静态创建的对象，就是使用静态初始化器。
```java
 public static Holder holder=new Holder(42);
```

静态初始化器由JVM在类的初始阶段执行，由于JVM内在的同步，该机制确保了这种方式初始化的对象可以被安全地发布。


### 高效不可变对象

一个对象在技术上不是不可变的，但是它的状态不会在发布后被修改，这样的对象称作有效不可变对象。


### 可变对象

如果对象在创建后被修改，那么安全发布仅仅可以保证”发布当时“状态的可见性。

发布对象的必要条件依赖于对象的可变性:

* 不可变对象可以通过任意机制发布
* 高效不可变对象必须要安全发布
* 可变对象必须要安全发布，同事必须要线程安全或被锁保护。

### 安全地共享对象

在并发程序中,使用和共享对象的一些最有效的策略如下:

线程限制:一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改。

共享只读:一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。

共享线程安全:一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意地访问它。

被守护的:一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。

## 组合对象

### 设计线程安全的类

设计线程安全类的过程应该包括下面3个基本要素:

* 确定对象状态是由哪些变量构成的;
* 确定限制状态变量的不变约束;
* 制定一个管理并发访问对象状态的策略。

同步策略定义了对象如何协调对其状态的访问,并且不会违反它的不变约束或后验条件。它规定了如何把不可变性、线程限制和锁结合起来，从而维护线程的安全性，还指明了哪些锁保护哪些变量。

### 收集同步需求

维护类的线程安全性意味着确保在并发访问的情况下，保护它的不变约束;这需要对其状态进行判断。对象与变量拥有一个状态空间:即它们可能处于的状态范围。状态空间越小，越容易判断它们。尽量使用fianl类型的域，就可以简化我们对对象的可能状态进行分析.

不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性。

### 状态的依赖操作

类的不变约束与方法的后验条件约束了对象合法的状态和合法状态转换。

### 状态所有权

在很多情况下，所有权与封装性总是在一起出现的；对象封装它拥有的状态，且拥有它封装的状态。拥有给定状态的所有者决定了锁协议，该协议用于维护变量状态的完整性。所有权意味着控制权，不过一旦你将引用发布到一个可变对象上，你就不再拥有独占的控制权，充其量只可能有”共享控制权“。类通常不会拥有由构造函数或方法传递进来的对象，除非该方法被明确设计用来转换传递对象的所有权（比如同步容器的包装工厂方法）。

### 实例限制

即使一个对象不是线程安全的，仍然有许多技术可以让它安全地用于多线程程序。比如，你可以确保它只被单一的线程访问(线程限制),也可以确保所有的访问都正确地被锁保护。

将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁。

限制性使构造线程安全的类变得更容易。因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序。

### Java监视器模式

线程限制原则的直接推论之一是Java监视器模式。遵循Java监视器模式的队形封装了所有的可状态，并由对象自己的内部锁保护。

使用私有锁对象，而不是对象的内部锁，有很多好处。私有的锁对象可以封装锁，这样客户代码无法得到它。

### 委托线程安全

### 同步策略的文档化

为类的用户编写类线程安全性担保的文档;为类的维护者编写类的同步策略文档。

## 构建块

### 同步容器

Vector和Hashtable,

### 迭代器和ConcurrentModificationException

如果在迭代器期间计数器被修改，hasNext或next会抛出ConcurrentModificationException.

ConcurrentModificationException也可能出现在单线程的代码中，当对象并非通过Iterator.remove，而是直接从容器中删除时，就会出现这个情况。

在迭代期间，对容器加锁的一个替代方法是复制容器。因为复制是线程限制的，没有其他的线程能够在迭代期间对其进行修改，这样消除了ConcurrentModificationException发生的可能性。（容器仍然需要在复制期间对自己枷锁）。复制容器会有明显的性能开销。

### 隐藏迭代器

尽管锁可以避免迭代器抛出ConcurrentModificationException，标准容器中的toString的实现会通过迭代容器中的每个元素，来获得关于容器内容格式良好的展现。

容器的hashCod和equals方法也会间接地调用迭代，比如当容器本身作为一个元素时，或者作为另一个容器的key时。类似地，containsAll、removeAll、retainAll方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所以这些对迭代间接调用，都可能会引起ConcurrentModificationException。

### 并发容器

Java5.0提供几种并发的容器类来改进同步容器
ConcurrentHashMap来代替Map
当多数操作为读取操作时：CopyOnWirteArrayList是List响应的同步实现。

用并发容器替换同步容器,这种作法以很小风险带来了可扩展性显著的提高。

Java 5.0同样添加了两个新的容器类型:Queue和BlockingQueue。Queue用来临时保存正在等待被进一步处理的一系列元素。

Java 6 加入了ConcurrentSkipListMap和ConcurrentSkipListSet,用来作为同步SortedMap和SortedSet的并发替代品。

### ConcurrentHashMap

ConcurrentHashMap使用一个更加细化的锁机制，名叫分离锁。这个机制允许更深层次的共享访问。任意数量的读线程可以并发访问Map,读者和写者也可以并发访问Map,并且有限数量的写线程还可以并发修改Map.

### CopyOnWriteArrayList



























