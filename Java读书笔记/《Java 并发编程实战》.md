《Java 并发编程实战》.md

## 线程的优点

恰当地使用线程时，可以降低开发和维护的开销，并且能够提高复杂应用的性能。

## 线程安全

一开始就将一个类设计成线程安全的，比在后期重新修复它更容易。

一个类是线程安全的是指在被多个线程访问时，类可以持续进行正确的行为。


## 原子性

## 竞争条件

### 惰性初始化

### 复合操作

我们将"检查在运行"和读-改-写操作的全部执行过程看作是复合操作。

### 锁

为了保护状态的一致性，要在单一的原子操作中更新相关的状态变量。

### 内部锁 synchronized

### 重进入 

### 活跃度与性能

通常简单性与性能质之间是互相牵制的。实现一个同步策略时，不要过早地为了性能而牺牲简单性(这是对安全性潜在的妥协)。

有些耗时的计算或操作，比如网络或I/O,难以快速完成。执行这些操作期间不要占有锁。

## 共享对象

### 可见性

### 过期数据

### 非原子的64位操作

当一个线程在没有同步的情况下读取变量，它可能得到一个过气质。但是至少它可以看到某个线程在那里设定的一个真实数值，而不是一个凭空而来的值。这样的安全性保证被称为最低限的安全性。

### 锁和可见性

锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能够看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步。

### Volatile 变量

只有当volatile变量能够简化实现和同步策略的验证时，才使用它们。当验证正确性必须推断可见性问题时，应该避免volatile变量。正确使用volatile变量的方式包括:用于确保它们所引用的对象状态的可见性，或者用于标识重要的生命周期事件(比如初始化或关闭)的发生。

只有满足下条件才能使用volatile变量

* 写入变量时并不依赖变量的当前值；或者能保证只有单一的线程修改变量的值

* 变量不需要与其他的状态变量共同参与不变约束

* 访问变量时，没有其他原因需要加锁。


### 发布和逸出

发布一个对象的意思是使它能够被当前范围之外的代码所使用。
逸出是指 一个对象在尚未准备好时就将它发布。

在很多情况下，我们需要确保对象及它们的内部状态不被暴露。最常见的发布对象方式是将对象的引用存储到公共静态域中。
另一种发布对象和它的内部状态的机制是发布一个内部类实例。


### 安全构件的实践

### 线程封闭

线程限制是你在程序设计中需要考虑的一个元素，它是在程序的实现中完成的。

### Ad-hoc 线程限制

维护线程限制性的任务全部落在实现上的这种情况交Ad-hoc线程限制。

### 栈限制

栈限制是线程限制的一种特列。在栈限制中，只能通过本地变量才可以触及对象。

### ThreadLocal

一种维护线程限制的更加规范的方式是使用TreadLocal,它允许你将每个线程与持有数据的对象关联在一起。


### 不可变性

不可变对象永远是线程安全的。

不可变性并不简单第等于将对象中的所有域声明为fianl类型。因为final域可以获得一个岛可变对象的引用。

只有满足如下状态，一个对象才是不可变的。

* 它的状态不能在创建后再被修改

* 所有域都是final类型

* 并且它被正确创建(创建期间没有发生this引用的逸出)

### Final域

final关键字源于C++的const机制，不过受到了更多的限制。它对不可变性对象的创建提供了支持。fianl域是不能修改的(尽管如果final域指向的对象是可变的，这个对象仍然可被修改)，然而它在Java存储模型中还有着特殊的语义。final域使得确保初始化安全性成为可能，初始化安全性让不可变性对象不需要同步就能自由地访问和共享。

即使对象是可变的，将一些域声明为fianl类型仍然有助于简化对其状态的判断。因为限制了对象的可见性，也就约束了其可能的状态集，即使有一两个可变的状态变量，这样一个"几乎不可变"的对象仍然比有很多的可变变量的对象要简单。将域声明为fianl类型，还向维护人员明确指出这些域是不能变的。

### 不可变对象与初始化安全性

处于不可变对象的重要性，Java存储模型为共享不可变对象提供了特殊的初始化安全性的保证。正如我们所见的，对象的引用对其他线程可见，并不意味对象的状态一定对消费线程可见。为了保证对象状态有一个一致性视图，我们需要同步。

另一方面，即使发布对象引用时没有使用同步，不可变对象仍然可以被安全地方问。为了获得这种初始化安全性的保证，应该满足所有不可变性的条件:不可修改的状态，所有域都是fianl类型的，以及正确的构造。


### 安全发布的模式

如果一个对象不是不可变的，它就必须被安全地发布，通常发布线程与消费线程必须同步化。

为了安全地发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布:
* 通过静态初始化器初始化对象的引用;
* 将它的引用存储到volatile域或者AtomicRefrence;
* 将它的引用存储到正确创建的对象的fianl域中;
* 或者将它的引用存储到由锁正确保护的域中。


线程安全库中的容器提供了如下的线程安全保证:

* 置于Hashtable，synchronizedMap、ConcureentMap中的主键以及键值，会安全地发布到可以从Map获得它们的任意线程中，无论是直接获得还是通过迭代器（interator）获得

* 置于Vecotr、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或者synchedSet中的元素，会安全地发布到可以从容器中获得它的任意线程中；

* 置于BlockingQueue或者ConcurrentLinkedQueue的元素，会安全地发布到可以从队列中获得它的任意线程中。


通常,以最简单和最安全的方式发布一个被静态创建的对象，就是使用静态初始化器。
```java
 public static Holder holder=new Holder(42);
```

静态初始化器由JVM在类的初始阶段执行，由于JVM内在的同步，该机制确保了这种方式初始化的对象可以被安全地发布。


### 高效不可变对象

一个对象在技术上不是不可变的，但是它的状态不会在发布后被修改，这样的对象称作有效不可变对象。


### 可变对象

如果对象在创建后被修改，那么安全发布仅仅可以保证”发布当时“状态的可见性。

发布对象的必要条件依赖于对象的可变性:

* 不可变对象可以通过任意机制发布
* 高效不可变对象必须要安全发布
* 可变对象必须要安全发布，同事必须要线程安全或被锁保护。

### 安全地共享对象

在并发程序中,使用和共享对象的一些最有效的策略如下:

线程限制:一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改。

共享只读:一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它。共享只读对象包括可变对象与高效不可变对象。

共享线程安全:一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意地访问它。

被守护的:一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已知被特定的锁保护起来的已发布对象。

## 组合对象

### 设计线程安全的类

设计线程安全类的过程应该包括下面3个基本要素:

* 确定对象状态是由哪些变量构成的;
* 确定限制状态变量的不变约束;
* 制定一个管理并发访问对象状态的策略。

同步策略定义了对象如何协调对其状态的访问,并且不会违反它的不变约束或后验条件。它规定了如何把不可变性、线程限制和锁结合起来，从而维护线程的安全性，还指明了哪些锁保护哪些变量。

### 收集同步需求

维护类的线程安全性意味着确保在并发访问的情况下，保护它的不变约束;这需要对其状态进行判断。对象与变量拥有一个状态空间:即它们可能处于的状态范围。状态空间越小，越容易判断它们。尽量使用fianl类型的域，就可以简化我们对对象的可能状态进行分析.

不理解对象的不变约束和后验条件，你就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性。

### 状态的依赖操作

类的不变约束与方法的后验条件约束了对象合法的状态和合法状态转换。

### 状态所有权

在很多情况下，所有权与封装性总是在一起出现的；对象封装它拥有的状态，且拥有它封装的状态。拥有给定状态的所有者决定了锁协议，该协议用于维护变量状态的完整性。所有权意味着控制权，不过一旦你将引用发布到一个可变对象上，你就不再拥有独占的控制权，充其量只可能有”共享控制权“。类通常不会拥有由构造函数或方法传递进来的对象，除非该方法被明确设计用来转换传递对象的所有权（比如同步容器的包装工厂方法）。

### 实例限制

即使一个对象不是线程安全的，仍然有许多技术可以让它安全地用于多线程程序。比如，你可以确保它只被单一的线程访问(线程限制),也可以确保所有的访问都正确地被锁保护。

将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁。

限制性使构造线程安全的类变得更容易。因为类的状态被限制后，分析它的线程安全性时，就不必检查完整的程序。

### Java监视器模式

线程限制原则的直接推论之一是Java监视器模式。遵循Java监视器模式的队形封装了所有的可状态，并由对象自己的内部锁保护。

使用私有锁对象，而不是对象的内部锁，有很多好处。私有的锁对象可以封装锁，这样客户代码无法得到它。

### 委托线程安全

### 同步策略的文档化

为类的用户编写类线程安全性担保的文档;为类的维护者编写类的同步策略文档。

## 构建块

### 同步容器

Vector和Hashtable,

### 迭代器和ConcurrentModificationException

如果在迭代器期间计数器被修改，hasNext或next会抛出ConcurrentModificationException.

ConcurrentModificationException也可能出现在单线程的代码中，当对象并非通过Iterator.remove，而是直接从容器中删除时，就会出现这个情况。

在迭代期间，对容器加锁的一个替代方法是复制容器。因为复制是线程限制的，没有其他的线程能够在迭代期间对其进行修改，这样消除了ConcurrentModificationException发生的可能性。（容器仍然需要在复制期间对自己枷锁）。复制容器会有明显的性能开销。

### 隐藏迭代器

尽管锁可以避免迭代器抛出ConcurrentModificationException，标准容器中的toString的实现会通过迭代容器中的每个元素，来获得关于容器内容格式良好的展现。

容器的hashCod和equals方法也会间接地调用迭代，比如当容器本身作为一个元素时，或者作为另一个容器的key时。类似地，containsAll、removeAll、retainAll方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所以这些对迭代间接调用，都可能会引起ConcurrentModificationException。

### 并发容器

Java5.0提供几种并发的容器类来改进同步容器
ConcurrentHashMap来代替Map
当多数操作为读取操作时：CopyOnWirteArrayList是List响应的同步实现。

用并发容器替换同步容器,这种作法以很小风险带来了可扩展性显著的提高。

Java 5.0同样添加了两个新的容器类型:Queue和BlockingQueue。Queue用来临时保存正在等待被进一步处理的一系列元素。

Java 6 加入了ConcurrentSkipListMap和ConcurrentSkipListSet,用来作为同步SortedMap和SortedSet的并发替代品。

### ConcurrentHashMap

ConcurrentHashMap使用一个更加细化的锁机制，名叫分离锁。这个机制允许更深层次的共享访问。任意数量的读线程可以并发访问Map,读者和写者也可以并发访问Map,并且有限数量的写线程还可以并发修改Map.

### CopyOnWriteArrayList

CopyOnWriteArrayList是同步List的一个并发产品，通常情况下它提供了更好的并发性，并避免了在迭代期间对容器加锁和复制。


### 阻塞队列和生产者-消费者模式

阻塞队列提供了可阻塞的put和take方法，它们与可定时的offer和poll是等价的。如果Queue已经满了，put方法会被阻塞直到有空间可用;如果Queue是空的，那么take方法会被阻塞，知道有元素可用。Queue的长度可以有限，也可以无限，无限的Queue永远不会充满，所以它的put方法永远不会阻塞。

阻塞队列支持生产者-消费者设计模式。一个生产者-消费者设计分离了”识别需要完成的工作“和”执行工作“。该模式不会发现一个工作便立即处理，而是把工作置于一个任务（”to do“）清单中，以备后期处理。生产者-消费者模式简化了开发，因为它解除了生产这类和消费者类之间相互依赖的代码。生产者和消费者以不同的或者变化的速度生产和消费着数据,生产者-消费者模式将这些活动解耦，因而简化了工作负荷的管理。


有界队列是强大的资源管理工具，用来建立可靠的应用程序:它们遏制哪些可以产生过多工作量、具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮。

LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列。与LinkedList和ArrayList相似，但是却拥有比同步List更好的并发性能。

### 双端队列和窃取工作

Java 6 新增了两个容器类型，Deque 和BlockingDeque,它们分别扩展Queue和BlockQueue。Deque是一个双端队列，允许高效地在头和尾分别进行插入和移除。
实现类是ArrayDeque和LinkedBlockingDeque。

窃取工作恰好适用于解决消费者与生产者同体的问题--当运行到一个任务的某单选时，可能会识别出更多的任务。当一个线程发现了一个新的任务单元时，它会把它放在自己队列的末尾(或者在另一种共享工作设计的情况下，可以放入其他工作者的队列中);当双端队列为空的时候，它会去其他队列的队尾寻找新的任务，这样能确保每一个线程都保持忙碌状态。

### 阻塞和可中断的方法

线程可能会因为几种原因被阻塞或暂停:等待I/O操作结束，等待获得一个锁，等待从Thread.sleep中唤醒，或者等待另一个线程的计算结果。当一个线程阻塞时，它通常被挂起，并被设置成线程阻塞的某个状态(BLOCKED、WAITING,或是TIMED_WAITING).

一个阻塞的操作和一个普通的操作之间的差别仅仅在于，被阻塞的线程必须等待一个事件的发生才能继续进行，并且这个事件是超越它自己控制的，因为需要花费更长的时间--等待I/O操作完成，锁可用，或者是外部计算结束。当外部事件发生后，线程被置回RUNNABLE状态，重新获得调度的机会。

BlockingQueue的put和take方法会抛出一个受检查的InterruptException,这与类库中其他的一些方法是相同的，比如Thread.sleep。当一个方法能够抛出InterruptException的时候，是在告诉你这个方法是一个可阻塞方法，进一步看，如果它被中断，将可以提前结束阻塞状态。

Thread提供了Interrupt方法，用来中断一个线程，或者查询某线程是否已经被中断。每一个线程都有布尔类型的属性，这个属性代表了线程的中断状态，中断线程时需要设置这个值。

中断是一种协作机制。一个线程不能够迫使其他线程停止正在做的事情，或者去做其他事情；当线程A中断B时，A仅仅是要求B在达到某个方便停止的关键点时，停止正在做的事情--如果它这样做是正确的。然而,在API或者语言规范中，任何特定应用级别的中断语义中，最常用的是取消一个活动。从时间角度来看，响应中断的阻塞方法，可以更容易地取消耗时的活动。

当你在代码中调用了一个抛出InterruptException的方法时，你自己的方法也就成为了一个阻塞方法，要为响应中断作好准备。在类库代码中，有两种基本选择:

传递InterruptException。如果你能侥幸避开异常的话，这通常是最明智的策略--只需要把InterruptException传递给你的调用者。这可能包括不捕获InterruptException,也可能是先捕获，然后对其中特定活动进行简洁地清理后，再抛出。

恢复中断。有时候你不能抛出InterruptException,比如当你的代码是Runnable的一部分时。再这样的情况下，你必须捕获InterruptException，并且，在当前线程中通过调用Interrupt从中断中恢复，这样调用栈中更高层的代码可以发现中断已经发生。

只有一种情况允许掩盖中断:你扩展了Thread,并因此控制了所有处于调用栈上层的代码。

### Synchronizer

阻塞队列在容器类中是独一无二的;它们不仅作为对象的容器，而且能够协调生产者线程和消费者线程之间的控制流，这是因为take和put会保持阻止状态直到队列进入了期望的状态。

Synchoronizer 是一个对象，它根据本身的状态调节线程的控制流。阻塞队列可以扮演一个Synchronizer的角色;其他类型的Synchronizer包括信号量(semaphore)、关卡(barrier)以及闭锁(latch)。

所有Synchronizer都享有类似的结构特效;它们封装状态,而这些状态决定着线程执行到在某一点时是通过还是被迫等待;它们还提供操控状态的方法,以及高效地等待Synchronizer进入到期望状态的方法。

### 闭锁

闭锁(latch)是一种Synchronizer，它可以延迟线程的进度直到线程到达终止(terminal)状态。一个闭锁工作起来就像一道大门;直到闭锁达到终点之前，门一直是关闭的，没有线程能够通过,在终点状态到来的时候,门开了，允许所有线程都通过。一但闭锁到达了终点状态，它就不能够在改变状态了，所以它会永远保持敞开状态。闭锁可以用来确保特定活动直到其他的活动完成后才发生，比如:

* 确保一个计算不会执行，直到它需要的资源被初始化。一个二元闭锁（两个状态）可以用来表达"资源R已经被初始化",并且所有需要用到R的活动首先都要在闭锁中等待。

* 确保一个服务不会开始,直到它依赖的其他服务都已经开始。每一个服务会包含一个相关的二元闭锁;开启服务S会首先开始等待闭锁S中所依赖的其他服务,在启动结束后，会释放闭锁S，这样所有依赖S的服务也可以开始处理了。

* 等待 ,直接活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。

CountDownLatch是一个灵活的闭锁实现，用于上述各种情况;允许一个或多个线程等待一个事件集的发生。

### FutureTask

FutureTask的实现描述了一个抽象的可携带结果的计算。
FutureTask的计算是通过Callable实现的，它等价于一个可携带结果的Runnable,并且有3个状态:等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦FutureTask进入完成状态，它会永远停止在这个状态上。

Future.get的行为依赖于任务的状态。如果它已经完成,get可以立刻得到返回结果，否则会被阻塞直到任务转入完成状态,然后会返回结果或者抛出异常。FutureTask把计算的结果从运行计算的线程传递到需要这个结果的线程;FutureTask的规约保证了这种传递建立在结果的安全发布基础上。

Executor框架利用FutureTask来完成异步任务,并可以用来进行任何潜在的耗时计算，而且可以在真正需要计算结果之前就启动他们开始计算。

### 信号量

计数信号量用来控制能够同事访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。计数信号量可以用来实现资源池或者给一个容器限定边界。



























