《深入理解Java虚拟机》.md

## 第1章 走进Java TODO

----

## 第2章 Java内存区域与内存溢出异常


### 运行时数据区域

方法区 Java虚拟机栈 本地方法栈 堆 程序计数器。

#### 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都需要有一个独立的程序计数器，即“线程私有”内存。在Java虚拟机规范中没有规定任何OutOfMemorError情况的区域。

#### Java虚拟机栈(Java Virtual Machine Stacks)

线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成都对应一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译器可知的各种基础类型、对象引用。

该区域规定了2个异常情况:

1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError.

2.如果虚拟机栈可以动态扩展时无法申请到足够的内存，则会抛出OutOfMemoryError。

#### 本地方法栈（Native Method Stack）

本地方法栈为虚拟机使用到的Native方法服务。

本地方法栈和虚拟机栈一样都会抛出StackOverflowError和OutOfMemoryError异常。

#### Java堆 (Java Heap)

Java 虚拟机所管理的内存中最大一块。且被所有线程共享的一块内存区域，存放对象实例。

从内存回收的角度来看，由于现在收集器基本都采用分代手机算法,所以Java堆中可以细分为:新生代和老年代。再细致一点的有Eden控件、Form Survivor空间、To Survivor空间等。

同样如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError。

#### 方法区（Method Area）

方法区 与 Java 堆一样，是各个线程共享的内存区域,它用于存储一倍虚拟机加载的类信息、常量、静态变量、及时编译器便后的代码等数据。


在JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常


##### 运行时常量池(Runtime Constant Pool)

运行时常量池是方法区的一部分.用于存放编译器生成的各种字面量和符号引用，这部分内柔将在类加载后进入方法区的运行时常量池中存放。

常量池无法申请到内存时也会抛出OutOfMemoryError.

#### 直接内存 (Direct Memory)

直接内存并不是虚拟机运行时数据区的一部分也不是Java虚拟机规范中定义的内存区域。在JDK1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

### HotSpot 虚拟机对象探秘

#### 对象的内存布局

HotSopt虚拟机中，对象在内存中存储的布局可以分为3个区域:对象头、实例数据、对齐填充。


#### Java堆溢出


java.lang.OutOfMemoryError会跟着进一步提示“Java heap space”

先分析是出现了内存泄漏（Memory Leak），还是内存溢出（Memory OverFlow）。

#### 虚拟机栈和本地方法栈溢出

1.如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError异常

2.如果虚拟机在扩展栈时无法申请到足够的内存区域，则抛出OutOfMemoryError异常


在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。


#### 方法区和运行时常量池溢出

1.6之前,运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是PermGen Space。


#### 本机直接内存溢出

## 第3章  垃圾收集器与内存分配策略

###  对象已死？

垃圾收集器在对堆进行回收前，第一件事就是确定这些对象中哪些还"存活"，哪些已经"死去"(即不可能在被任何途径使用的对象)。

####  引用计数法

给对象中添加一个引用计数器。每当有一个地方引用它时，计算器就加1.当引用失效时，计数器值就减1.

但是无法解决对象之间互相循环引用的问题。

#### 可达性分析算法

当一个对象到GC Roots没有任何引用脸相连时，则证明此对象是不可用的。

Java中，可作为GC Roots的对象包括下面几种:

1.虚拟机栈（栈帧中的本地变量表）中引用的对象

2.方法区中类静态属性引用的对象。

3.方法区中常量引用的对象

4.本地方法栈中JNI(即一般说的Native方法)引用的对象。

#### 再谈引用

Java1.2之后。

引用分为：

1.强引用（Strong Reference）在代码中普遍存在的即："Object obj=new Object()。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

2.软引用（Soft Reference）在系统将发生内存溢出异常之前，将会对这些对象进行二次回收。回收后没有足够的内存，则会抛出内存溢出异常。

3.弱引用（Weak Refrence）也是用来描述非必须对象的,但是它的强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次GC发生之前。

4.虚引用（Phantom Reference）.为一个对象设置虚引用关联的唯一目的是能在这个对象呗收集器回收时收到一个系统通知。


#### 回收方法区

方法区/HotSpot的永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。

无用类的判断条件:

1.该类的所有的实例都已经被回收。

2.加载该类的ClassLoader已经被回收

3.该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


### 垃圾收集算法

#### 标记-清除算法

首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的额对象。
存在2个不足:1.效率问题。2.控件问题 标记清楚后产生大量不连续的内存碎片，导致后续分配脚打对象时，无法找到足够的连续的内存而不得不提前触发另一次垃圾收集动作。 

#### 复制算法

将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，将还存活的队形复制到另一块上面。然后再把使用过的内存空间清理掉。这样使得每次都是对整个半区进行内存回收。

HotSpot虚拟机默认Eden 和Survivor的大小比例是8:1.

#### 标记-整理算法

标记过程与标记清除算法一样。整理是将所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

#### 分代收集算法

一般划分为新生代和老年代。在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法。而老年代中因为对象存活率搞，没有额外控件对它进行分配担保，则使用“标记-清除”或者“标记-整理”算法来进行回收

### HotSpot的算法实现

#### 枚举根节点

#### 安全点

安全点的选定基本上是以程序"是否具有让程序长时间执行的特征"为标准来进行选定的。

#### 安全区域

指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的。

### 垃圾收集器

JDK1.7 Update14之后的HotSpot虚拟机。

并行:多条垃圾收集线程并行工作，但此时用户显示仍然处于等待状态。

并发:指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行),用户程序在继续运行，而垃圾收集程序运行于另一个CPU上.


#### Serial 收集器

Serial收集器在进行垃圾收集时，必须暂停其他所有的工作线程，知道它收集结束。

#### ParNew 收集器

ParNew 收集器其实就是Serial收集器的多线程版本。目前只有它能与CMS 收集器配合工作。


#### Parallel Scavenge “吞吐量优先”收集器

特点是它关注点与其他收集器不同，它的目标则是达到一个可控制的吞吐量。

#### Serial Old 收集器

Serial Old是Serial 收集器的老年代版本，它同样是一个单线程收集器，使用"标记-整理"算法.

这个收集器的主要意义也是在与给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途:一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用，另一种用途是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

#### Parallel Old 收集器

Parallel Old是Parallel Scavenge 收集器的老年代版本,使用多线程和“标记-整理”算法。Java1.6才开始提供。

#### CMS 收集器 （并发低停顿收集器）

是一种以获取最短回收停顿时间为目标的收集器。适用于互联网站或者B/s系统的服务端上。

基于“标记-清除”算法。运行过程:
1.初始标记
2.并发标记
3.重新标记
4.并发清除


优点: 并发收集、低停顿。

缺点:

1.CMS收集器对CPU资源非常敏感。

2.无法处理浮动垃圾。浮动垃圾，这一次无法集中处理被留到下一次GC的垃圾。

3.基于“标记-清除”算法，容易造成空间碎片过多，无法给大对象分配内存。

#### G1收集器

JDK1.7 RoadMap里面。面向服务端应用的垃圾收集器。

特点:

1.并发与并行

2.分代收集

3.空间整合。整体基于“标记-整理”算法。

4.可预测的停顿

运行步骤(不计算维护Remembered Set的操作):

1.初始标记

2.并发标记

3.最终标记

4.筛选回收

#### 理解GC日志

```

33.125:[GC[DefNew:3324K->152K(3712K),0.0025925 secs]3324K->152K(11904K),0.0031680 secs]

100.667:[Full GC[Tenured:0K->210K(10240K),0.0149142 secs]4603K->210K(19456K),[Perm: 2999K->2999K(21248K)],0.0150007 secs][Times:user=0.01 sys=0.00,real=0.02 secs]

```


开头的数字代表 Java虚拟机启动以来经过的秒数

GC日志开头的”[GC“ 和”[Full GC“ 说明了这次垃圾收集的停顿类型。

Full代表这次GC发生了Stop-The-World。

接下来的"[DefNew"、"[Tenured"、"[Perm"表示发生GC的区域。

后面方括号内部的“3324K->152k(3712K)”表示“GC前该内存区域已使用容量->GC后该内存区域已使用容量(该内存区域总容量)”。

方括号之后外的“3324k->152k(11904k)”表示“GC前Java堆已使用容量->GC后Java堆已使用容量(Java堆总容量)”。

再往后“0.0025825 secs”表示该内存区域GC所用时间，单位是秒。
有的收集器会给出更具体的时候，如“[Times:user=0.01 sys=0.00,real=0.02 secs]”,这里的user代表用户态消耗的CPU时间、sys代表内核态小号的CPU时间（不包含非运算的等待耗时），real代表操作从开始到结束所经过的墙钟时间（包括各种非运算的等待耗时，如等待磁盘I/O,等待线程阻塞）。当多CPU或者多核时，多线程操作会叠加CPU时间,所以会出现user/sys时间大于real时间。


### 内存分配与回收策略

文中是在Serial/Serial Old收集器下的内存分配和回收的策略。

#### 对象优先在Eden分配

Minor GC 新生代GC:指发生在新生代的垃圾收集动作，回收速度很快。


Full/Major GC 老年代GC:发生在老年代的GC，比Minor GC 慢10倍以上。


#### 大对象直接进入老年代

大对象是指需要大量连续内存空间的Java对象。例如长字符串或者数组.

#### 长期存活的对象将进入老年代

#### 动态对象年龄判定

#### 空间分配担保

----

## 第4章 虚拟机性能监控与故障处理工具 TODO

----

## 第5章 调优案例分析与实战 TODO

----

## 第6章 类文件结构 TODO

### 无关性的基石

Java虚拟机不关心Class的来源是何种语言。

### Class类文件的结构

### 魔数与Class文件的版本

每个Class文件中的头4个字节称为魔数，它的唯一作用是用来确定这个条件是否为一个能被虚拟机接受的Class文件。

紧接着魔数的4个字节存储的是Class文件的版本号:第5和第6个字节是次版本号，第7和第8个字节是主版本号。

### 常量池

主次版本号之后是常量池入口，常量池可以理解为Class文件之中的资源仓库。常量入口需要放置一项u2类型的数据，代表常量池容量计数值。容量计数是从1而不是从0开始，0是用来满足不引用任何一个常量池项目。

常量池中存放两大类常量:字面量和符号引用。

字面量如文本字符串，声明为fianl的常量值。

符号引用包含:
1.类和接口的全限定名
2.字段的名称和描述符
3.方法的名称和描述符

javap -verbose 输出.class 文件字节码内容

### 访问标志

在常量池结束之后，紧接着的两个字节代表访问标志。用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口，是否定义为public，是否为abstract。如果是类，是否为final等。

### 类索引、父类索引与接口索引集合

### 字段表集合

字段表用于描述接口或者类中声明的变量。字段表集合中不会列出从超类/父接口中继承而来的字段，但有可能理出原本Java代码中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

### 方法表集合

### 属性表集合

1.Code属性。Java程序方法体中的代码经过Javac编译器处理后，最终变成字节码指令存储在Code属性内。

code_length .虚拟机规范明确限定一个方法不允许超过65535条字节码指令。


### Exceptions属性

用于列举出方法中可能抛出的受查异常。

### LineNumberTable属性

用于描述Java源码行号与字节码行号之间的对应关系。

### LocalVariableTable属性

用于描述栈帧中局部变量表中的标量与Java源码中定义的变量之间的关系。

1.5引入泛型之后。增加了LocalVariableTypeTable.用于无法准确描述泛型类型

### SourceFile属性

用于记录生成这个Class文件的源码文件名称。

### ConstantValue

通知虚拟机自动为静态变量赋值。

### InnerClasses属性

用于记录内部类与宿主类之间的关联

### Deprecated及Synthetic属性

都属于标志类型的布尔属性。

Deprecated 用于表示某个类、字段或者方法。程序作者不推荐使用。

Synthetic 代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的。

### StackMapTable属性

复杂的变长属性，位于Code属性的属性表中。

### Signature

可选定长属性，可以出现于类、属性表和方法表结构的属性表中。

### BootstrapMethods

复杂的变长属性，位于类文件的属性表中。


### 字节码指令简介

### 字节码与数据类型

### 加载和存储指令

### 运算指令

### 类型转换指令

### 对象创建与访问指令

### 操作数栈管理指令

### 控制转移指令

### 方法调用和返回指令

1.invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，这也是Java语言中最常见的方法分派方式。

2.invokeinterface 用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用

3.invokespecial用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法

4.invokestatic 用于调用类方法（static方法）

5.invokedynamic指定用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。分派逻辑是由用户所设定的引导方法决定的。

### 异常处理指令

### 同步指令

java虚拟机的指令集有monitorenter和monitorexit两条指令为支持synchronized关键字的语义。

### 公有设计和私有实现

----

## 第7章 虚拟机类加载机制 

虚拟机把描述类的数据从Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

类的加载、连接、初始化过程是在程序运行期间完成的。

### 类加载的时机

生命周期: 加载、验证、准备、解析、初始化、使用、卸载。

其中 验证、准备、解析统称为连接。


初始化 ，虚拟机规定5中情况必须初始化。【主动引用】

1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。如果类没进行初始化，则需要先触发初始化。

2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化

3.当初始化一个类的时候，如果其父类还没有进行初始化，则需要先触发其父类的初始化。

4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。

5.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

5种触发类初始化的场景 ，虚拟机规范中使用了一个很强烈的限定语:"有且只有"。


被动引用:

1.通过子类引用父类的静态字段。不会导致子类初始化。

2.通过数组定义来引用类，不会触发此类的初始化。

3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。


接口初始化与类真正的区别在于第三种情况：

在接口初始化时，并不要求其父类接口全部都完成了初始化，只有真正用到父类接口的时候后，才会初始化父类接口。

### 类加载过程

#### 加载

"加载" 是 "类加载" 过程的一个阶段。

1.通过一个类的全限定名来获取定义此类的二进制字节流。

2.将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。

3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

数组类的创建过程遵循以下规则：

1.如果数组的组件类型是引用类型，那就地柜采用本节中定义的加载过程去加载这个组件类型。

2.如果数组的组件类型不是引用类型，java虚拟机将会把数组标记为与引导类加载器关联

3.数组类的可见性与它组件类型的可见性一致，如果组件类型不是引用类型，则数组可见性为public。


#### 验证

验证是为了确保Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

4个校验动作：

1.文件格式验证
2.元数据验证
3.字节码验证
4.符号引用验证

#### 准备

准备阶段是正是为类变量分配内存并设置类变量初始值的阶段，这里进行内存分配的仅包含类变量(被static修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着队形一起分配在Java堆中。这里的初始值"通常情况"下死数据类型的零值。

#### 解析

符号引用: 符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。

直接引用:直接指向目标的指针、相对偏移量或者是一个能简介定位到目标的句柄。同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。

#### 初始化

初始化阶段是执行类构造器`<clinit>()`方法的过程。

### 类加载器

虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

#### 类与类加载器

比较两个类是否"相等",只有在这两个类是由同一个类加载器加载的前提下才有意义。

#### 双亲委派模型

从Java虚拟机的角度来讲，只存在两个不同的类加载器:一种是启动类加载器(Bootstrap ClassLoader)，这个类加载器使用C++语言实现，是虚拟机自身的一部分。另一种就是所有其他的类加载器，由Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader。


双亲委派模型的工作过程:如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试去加载。

----

## 第12章 Java内存模型与线程


### Java 内存模型

#### 主内存与工作内存

#### 对于volatile型变量的特殊规则

当一个变量定义为volatile之后，它将具备两种特性，第一是保证次变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即的知的。

由于volatile变量只能保证可见性，在不符合以下两条规则的情况的运算场景中，我们仍要通过枷锁(使用synchronized或java.util.concurrent中的原子类)来保证原子性。

1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值

2.变量不需要与其他的状态变量共同参与不变约束。


使用volatile变量的第二个语义是禁止指令重排序优化。


### 对long和double型变量的特殊规则

目前各种平台下的商用虚拟机几乎都选择把64位数据点额读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。


### 原子性、可见性、有序性

原子性:由java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store、write。我们大致可以认为基本数据类型的访问读写是具备原子性的。

可见性:可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知该修改。volatile，synchronized，final

有序性:如果在本线程内观察，所有的操作都是有序的。如果在一个线程中观察另一个线程，所有的操作都是无序的。

### 先行发生原则 Happens-before

1. 程序次序规则: 在一个线程中,按照控制流顺序，书写在签名的操作线性发生于书写在后面的操作。

2.管程锁定规则:一个unlock操作先行发生于后面对同一个锁 的lock操作。这里必须强调是同一个锁，而”后面“是指时间上的先后顺序。

3.volatile变量规则: 对一个volatile变量的写操作线性发生于后面对这个变量的读操作，这里的”后面“同样是指时间上的先后顺序。

4.线程启动规则:Thread对象的start()方法先行发生于此线程的每一个动作

5.线程终止规则:线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。

6.线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。

7.对象终结规则:一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始

8.传递性:如果操作A先行于操作B,操作B先行于操作C,则操作A先行于操作C。

时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。

### Java与线程

#### 线程的实现

线程是CPU调度的基本单位。

实现线程主要有3种方式:使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。

### 状态转换

线程状态有5种

1.新建:创建后尚未启动的线程处于这种状态

2.运行:Runnable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间

3.无限期等待:处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显示地的唤醒。以下方法会让线程陷入无限期的等待状态:
	* 没有设置Timeout参数的Object.wait()方法
	* 没有设置Timeout参数的Thread.join()方法
	* LockSupport.park()方法

4.限期等待:处于这种状态的线程也不会被分配CPU执行时间,不过无须等待被其他线程显示地唤醒，在一定时间之后，它们会被系统自动唤醒。以下方法会让线程进入限期等待状态:

	* Thread.sleep()方法 
	* 设置Timeout参数的Object.wait()方法
	* 设置Timeout参数的Thread.join()方法
	* LockSupport.parkNanos()方法
	* LockSupport.parkUntil()方法

5.阻塞: 线程被阻塞了，“阻塞状态”与“等待状态”的区别是:
”阻塞状态“在等待着获取到一个非他锁，这个事件将在另一个线程放弃这个锁的时候发生;而”等待状态“则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。

6.结束:已终止线程的线程状态，线程已经结束执行。

## 线程安全与锁优化

当多个线程访问一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。




















