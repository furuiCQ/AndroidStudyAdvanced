《深入理解Java虚拟机》.md

## 第1章 走进Java TODO

----

## 第2章 Java内存区域与内存溢出异常


### 运行时数据区域

方法区 Java虚拟机栈 本地方法栈 堆 程序计数器。

#### 程序计数器（Program Counter Register）

程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。每条线程都需要有一个独立的程序计数器，即“线程私有”内存。在Java虚拟机规范中没有规定任何OutOfMemorError情况的区域。

#### Java虚拟机栈(Java Virtual Machine Stacks)

线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成都对应一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译器可知的各种基础类型、对象引用。

该区域规定了2个异常情况:

1.如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError.

2.如果虚拟机栈可以动态扩展时无法申请到足够的内存，则会抛出OutOfMemoryError。

#### 本地方法栈（Native Method Stack）

本地方法栈为虚拟机使用到的Native方法服务。

本地方法栈和虚拟机栈一样都会抛出StackOverflowError和OutOfMemoryError异常。

#### Java堆 (Java Heap)

Java 虚拟机所管理的内存中最大一块。且被所有线程共享的一块内存区域，存放对象实例。

从内存回收的角度来看，由于现在收集器基本都采用分代手机算法,所以Java堆中可以细分为:新生代和老年代。再细致一点的有Eden控件、Form Survivor空间、To Survivor空间等。

同样如果在堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError。

#### 方法区（Method Area）

方法区 与 Java 堆一样，是各个线程共享的内存区域,它用于存储一倍虚拟机加载的类信息、常量、静态变量、及时编译器便后的代码等数据。


在JDK1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。

当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常


##### 运行时常量池(Runtime Constant Pool)

运行时常量池是方法区的一部分.用于存放编译器生成的各种字面量和符号引用，这部分内柔将在类加载后进入方法区的运行时常量池中存放。

常量池无法申请到内存时也会抛出OutOfMemoryError.

#### 直接内存 (Direct Memory)

直接内存并不是虚拟机运行时数据区的一部分也不是Java虚拟机规范中定义的内存区域。在JDK1.4中新加入了NIO(New Input/Output)类,引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。

### HotSpot 虚拟机对象探秘

#### 对象的内存布局

HotSopt虚拟机中，对象在内存中存储的布局可以分为3个区域:对象头、实例数据、对齐填充。


#### Java堆溢出


java.lang.OutOfMemoryError会跟着进一步提示“Java heap space”

先分析是出现了内存泄漏（Memory Leak），还是内存溢出（Memory OverFlow）。

#### 虚拟机栈和本地方法栈溢出

1.如果线程请求的栈深度大于虚拟机允许的最大深度，将抛出StackOverflowError异常

2.如果虚拟机在扩展栈时无法申请到足够的内存区域，则抛出OutOfMemoryError异常


在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。


#### 方法区和运行时常量池溢出

1.6之前,运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是PermGen Space。


#### 本机直接内存溢出

## 第3章  垃圾收集器与内存分配策略

###  对象已死？

垃圾收集器在对堆进行回收前，第一件事就是确定这些对象中哪些还"存活"，哪些已经"死去"(即不可能在被任何途径使用的对象)。

####  引用计数法

给对象中添加一个引用计数器。每当有一个地方引用它时，计算器就加1.当引用失效时，计数器值就减1.

但是无法解决对象之间互相循环引用的问题。

#### 可达性分析算法

当一个对象到GC Roots没有任何引用脸相连时，则证明此对象是不可用的。

Java中，可作为GC Roots的对象包括下面几种:

1.虚拟机栈（栈帧中的本地变量表）中引用的对象

2.方法区中类静态属性引用的对象。

3.方法区中常量引用的对象

4.本地方法栈中JNI(即一般说的Native方法)引用的对象。

#### 再谈引用

Java1.2之后。

引用分为：

1.强引用（Strong Reference）在代码中普遍存在的即："Object obj=new Object()。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

2.软引用（Soft Reference）在系统将发生内存溢出异常之前，将会对这些对象进行二次回收。回收后没有足够的内存，则会抛出内存溢出异常。

3.弱引用（Weak Refrence）也是用来描述非必须对象的,但是它的强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次GC发生之前。

4.虚引用（Phantom Reference）.为一个对象设置虚引用关联的唯一目的是能在这个对象呗收集器回收时收到一个系统通知。


#### 回收方法区

方法区/HotSpot的永久代的垃圾收集主要回收两部分内容:废弃常量和无用的类。

无用类的判断条件:

1.该类的所有的实例都已经被回收。

2.加载该类的ClassLoader已经被回收

3.该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。


### 垃圾收集算法

#### 标记-清除算法

首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的额对象。
存在2个不足:1.效率问题。2.控件问题 标记清楚后产生大量不连续的内存碎片，导致后续分配脚打对象时，无法找到足够的连续的内存而不得不提前触发另一次垃圾收集动作。 

#### 复制算法

将内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，将还存活的队形复制到另一块上面。然后再把使用过的内存空间清理掉。这样使得每次都是对整个半区进行内存回收。

HotSpot虚拟机默认Eden 和Survivor的大小比例是8:1.

#### 标记-整理算法

标记过程与标记清除算法一样。整理是将所有存活的对象都向一端移动，然后清理掉端边界以外的内存。

#### 分代收集算法

一般划分为新生代和老年代。在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法。而老年代中因为对象存活率搞，没有额外控件对它进行分配担保，则使用“标记-清除”或者“标记-整理”算法来进行回收

### HotSpot的算法实现

#### 枚举根节点

#### 安全点

安全点的选定基本上是以程序"是否具有让程序长时间执行的特征"为标准来进行选定的。

#### 安全区域

指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的。

### 垃圾收集器

JDK1.7 Update14之后的HotSpot虚拟机。

并行:多条垃圾收集线程并行工作，但此时用户显示仍然处于等待状态。

并发:指用户线程与垃圾收集线程同时执行(但不一定是并行，可能会交替执行),用户程序在继续运行，而垃圾收集程序运行于另一个CPU上.


#### Serial 收集器

Serial收集器在进行垃圾收集时，必须暂停其他所有的工作线程，知道它收集结束。

#### ParNew 收集器

ParNew 收集器其实就是Serial收集器的多线程版本。目前只有它能与CMS 收集器配合工作。


#### Parallel Scavenge “吞吐量优先”收集器

特点是它关注点与其他收集器不同，它的目标则是达到一个可控制的吞吐量。

#### Serial Old 收集器

Serial Old是Serial 收集器的老年代版本，它同样是一个单线程收集器，使用"标记-整理"算法.

这个收集器的主要意义也是在与给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途:一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge 收集器搭配使用，另一种用途是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。

#### Parallel Old 收集器

Parallel Old是Parallel Scavenge 收集器的老年代版本,使用多线程和“标记-整理”算法。Java1.6才开始提供。

#### CMS 收集器 （并发低停顿收集器）

是一种以获取最短回收停顿时间为目标的收集器。适用于互联网站或者B/s系统的服务端上。

基于“标记-清除”算法。运行过程:
1.初始标记
2.并发标记
3.重新标记
4.并发清除


优点: 并发收集、低停顿。

缺点:

1.CMS收集器对CPU资源非常敏感。

2.无法处理浮动垃圾。浮动垃圾，这一次无法集中处理被留到下一次GC的垃圾。

3.基于“标记-清除”算法，容易造成空间碎片过多，无法给大对象分配内存。

#### G1收集器

JDK1.7 RoadMap里面。面向服务端应用的垃圾收集器。

特点:

1.并发与并行

2.分代收集

3.空间整合。整体基于“标记-整理”算法。

4.可预测的停顿

运行步骤(不计算维护Remembered Set的操作):

1.初始标记

2.并发标记

3.最终标记

4.筛选回收

#### 理解GC日志

```

33.125:[GC[DefNew:3324K->152K(3712K),0.0025925 secs]3324K->152K(11904K),0.0031680 secs]

100.667:[Full GC[Tenured:0K->210K(10240K),0.0149142 secs]4603K->210K(19456K),[Perm: 2999K->2999K(21248K)],0.0150007 secs][Times:user=0.01 sys=0.00,real=0.02 secs]

```


开头的数字代表 Java虚拟机启动以来经过的秒数

GC日志开头的”[GC“ 和”[Full GC“ 说明了这次垃圾收集的停顿类型。

Full代表这次GC发生了Stop-The-World。

接下来的"[DefNew"、"[Tenured"、"[Perm"表示发生GC的区域。

后面方括号内部的“3324K->152k(3712K)”表示“GC前该内存区域已使用容量->GC后该内存区域已使用容量(该内存区域总容量)”。

方括号之后外的“3324k->152k(11904k)”表示“GC前Java堆已使用容量->GC后Java堆已使用容量(Java堆总容量)”。

再往后“0.0025825 secs”表示该内存区域GC所用时间，单位是秒。
有的收集器会给出更具体的时候，如“[Times:user=0.01 sys=0.00,real=0.02 secs]”,这里的user代表用户态消耗的CPU时间、sys代表内核态小号的CPU时间（不包含非运算的等待耗时），real代表操作从开始到结束所经过的墙钟时间（包括各种非运算的等待耗时，如等待磁盘I/O,等待线程阻塞）。当多CPU或者多核时，多线程操作会叠加CPU时间,所以会出现user/sys时间大于real时间。


### 内存分配与回收策略

文中是在Serial/Serial Old收集器下的内存分配和回收的策略。

#### 对象优先在Eden分配

Minor GC 新生代GC:指发生在新生代的垃圾收集动作，回收速度很快。


Full/Major GC 老年代GC:发生在老年代的GC，比Minor GC 慢10倍以上。


#### 大对象直接进入老年代

大对象是指需要大量连续内存空间的Java对象。例如长字符串或者数组.

#### 长期存活的对象将进入老年代

#### 动态对象年龄判定

#### 空间分配担保

----

## 第4章 虚拟机性能监控与故障处理工具 TODO

----

## 第5章 调优案例分析与实战 TODO

----

## 第6章 类文件结构 TODO





----

## 第7章 虚拟机类加载机制 

虚拟机把描述类的数据从Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

类的加载、连接、初始化过程是在程序运行期间完成的。

### 类加载的时机

生命周期: 加载、验证、准备、解析、初始化、使用、卸载。

其中 验证、准备、解析统称为连接。


初始化 ，虚拟机规定5中情况必须初始化。【主动引用】

1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。如果类没进行初始化，则需要先触发初始化。

2.使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化

3.当初始化一个类的时候，如果其父类还没有进行初始化，则需要先触发其父类的初始化。

4.当虚拟机启动时，用户需要指定一个要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类。

5.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

5种触发类初始化的场景 ，虚拟机规范中使用了一个很强烈的限定语:"有且只有"。


被动引用:

1.通过子类引用父类的静态字段。不会导致子类初始化。

2.通过数组定义来引用类，不会触发此类的初始化。

3.常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。


接口初始化与类真正的区别在于第三种情况：

在接口初始化时，并不要求其父类接口全部都完成了初始化，只有真正用到父类接口的时候后，才会初始化父类接口。

### 类加载过程

#### 加载

"加载" 是 "类加载" 过程的一个阶段。

1.通过一个类的全限定名来获取定义此类的二进制字节流。

2.将这个字节流代表的静态存储结构转化为方法区的运行时数据结构。

3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

数组类的创建过程遵循以下规则：

1.如果数组的组件类型是引用类型，那就地柜采用本节中定义的加载过程去加载这个组件类型。

2.如果数组的组件类型不是引用类型，java虚拟机将会把数组标记为与引导类加载器关联

3.数组类的可见性与它组件类型的可见性一致，如果组件类型不是引用类型，则数组可见性为public。


#### 验证

验证是为了确保Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

4个校验动作：

1.文件格式验证
2.元数据验证
3.字节码验证
4.符号引用验证

#### 准备

准备阶段是正是为类变量分配内存并设置类变量初始值的阶段，这里进行内存分配的仅包含类变量(被static修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着队形一起分配在Java堆中。这里的初始值"通常情况"下死数据类型的零值。

#### 解析

符号引用: 符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可。

直接引用:直接指向目标的指针、相对偏移量或者是一个能简介定位到目标的句柄。同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。
























