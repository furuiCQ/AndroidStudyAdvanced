参考资料:

《深入理解java虚拟机》第二版

## 垃圾回收

### 引用计数法

它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。弊端: 无法处理循环引用对象。


### 可达性分析

通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。


#### GC Roots: 是一组必须活跃的引用。而它可以用于判断某些对象与GC Roots是否有关联，如果没有关联则回收这些对象。

java中可以做为GC Roots的对象
1.虚拟机栈(栈帧中的本地变量表)中引用的对象
2.方法区中类静态属性引用的对象
3.方法区常量引用的对象
4.本地方法栈中JNI(native方法)中引用的对象


#### 引用

在JDK1.2以前，Java中引用的定义很传统: 如果引用类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。这种定义有些狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态。我们希望能描述这一类对象: 当内存空间还足够时，则能保存在内存中；如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象。很多系统中的缓存对象都符合这样的场景。
在JDK1.2之后，Java对引用的概念做了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种，这四种引用的强度依次递减。

1.强引用(Strong reference) 强引用是代码中普遍存在的。例如:Object obj=new Object()。只要obj没有赋值为null。垃圾回收器将永远不会回收调obj指向的new Object()的对象实例。

2.软引用(Soft reference) 软引用是代表了该对象还有用但不是必须存在的。当系统将要内存溢出之前，垃圾回收期将会把软引用的对象列如回收范围，如果这次回收后还是内存不足，则会抛出内存溢出异常OOM。

3.弱引用(Weak reference) 弱引用是比软引用强度更低的引用。被弱引用关联的对象只能存活到下一次GC之前。垃圾回收器不管内存是否充足都会回收掉弱引用关联的对象。

4.虚引用(Phantom Reference)虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

总结:Android编程中，可以对于不常用的对象尽量使用软引用/弱引用。例如MVP中的Presenter。而强引用的对象，在Activity/Fragment销毁后确定不在使用，则赋值为null,这样垃圾回收器将会回收该引用，例如Webview。当然Webview有时候可以不回收方便快速加载，具体情况具体分析。



//TODO 待阅读完书籍后待补充。


